#!/usr/bin/env bash
# One-click deployment for Tencent Cloud Ubuntu (x86_64)
# - Deploys Go backend + React frontend with Docker Compose
# - Uses host-installed MySQL (no DB container)
# - Nginx reverse proxy in container (production profile)
# - Secure defaults (no DB/Redis ports exposed)
#
# Usage:
#   sudo bash scripts/deploy-tencent.sh \
#     --domain your.domain.com \
#     --db-user root \
#     --db-password 'your_password' \
#     --db-name blog_db \
#     --jwt-secret 'your_jwt_secret' \
#     [--db-host host.docker.internal] [--db-port 3306]
#
# Notes:
# - Assumes you have pushed your project files to the server (this script runs on the server)
# - Requires Ubuntu 20.04+ and internet access
# - If you have SSL cert/key, place them at docker/nginx/ssl/fullchain.pem and docker/nginx/ssl/privkey.pem before running

set -euo pipefail

PROJECT_DIR="$(cd "$(dirname "$0")/.." && pwd)"
# Defaults (can be overridden by existing .env.prod and CLI args)
DOMAIN=""
DB_HOST="host.docker.internal"
DB_PORT="3306"
DB_USER=""
DB_PASSWORD=""
DB_NAME="blog_db"
JWT_SECRET=""

color() { printf "\033[%sm%s\033[0m\n" "$1" "$2"; }
info()  { color "36" "[INFO]  $1"; }
success(){ color "32" "[OK]    $1"; }
warn()  { color "33" "[WARN]  $1"; }
error() { color "31" "[ERROR] $1"; }

require_root() {
  if [[ "${EUID}" -ne 0 ]]; then
    error "Please run as root: sudo bash scripts/deploy-tencent.sh ..."
    exit 1
  fi
}

load_existing_env() {
  # Load existing production env to allow reading DOMAIN and other values from file
  if [[ -f "${PROJECT_DIR}/.env.prod" ]]; then
    info "Loading existing .env.prod"
    # shellcheck disable=SC1091
    set -a; source "${PROJECT_DIR}/.env.prod"; set +a
    # Note: variables from file now populate the environment and will be used as defaults
  fi
}

parse_args() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --domain) DOMAIN="$2"; shift 2;;
      --db-host) DB_HOST="$2"; shift 2;;
      --db-port) DB_PORT="$2"; shift 2;;
      --db-user) DB_USER="$2"; shift 2;;
      --db-password) DB_PASSWORD="$2"; shift 2;;
      --db-name) DB_NAME="$2"; shift 2;;
      --jwt-secret) JWT_SECRET="$2"; shift 2;;
      -h|--help)
        grep -E "^#" "$0" | sed -E 's/^# ?//'; exit 0;;
      *) warn "Unknown arg: $1"; shift;;
    esac
  done

  # Allow values to come from existing .env.prod; only error if still missing
  [[ -n "$DB_USER" ]] || { error "--db-user is required (or set DB_USER in .env.prod)"; exit 1; }
  [[ -n "$DB_PASSWORD" ]] || { error "--db-password is required (or set DB_PASSWORD in .env.prod)"; exit 1; }
  [[ -n "$JWT_SECRET" ]] || { error "--jwt-secret is required (or set JWT_SECRET in .env.prod)"; exit 1; }
}

check_os() {
  . /etc/os-release || { error "/etc/os-release not found"; exit 1; }
  info "Detected: $NAME $VERSION ($ID $VERSION_ID)"
  if [[ "$ID" != "ubuntu" ]]; then
    warn "This script is tested on Ubuntu only. Continuing anyway..."
  fi
}

install_prereqs() {
  info "Installing prerequisites (curl, ca-certificates, gnupg, docker, compose-plugin)"
  apt-get update -y
  apt-get install -y ca-certificates curl gnupg lsb-release

  if ! command -v docker >/dev/null 2>&1; then
    install -m 0755 -d /etc/apt/keyrings
    curl -fsSL https://download.docker.com/linux/ubuntu/gpg | gpg --dearmor -o /etc/apt/keyrings/docker.gpg
    chmod a+r /etc/apt/keyrings/docker.gpg
    echo \
      "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
      $(. /etc/os-release && echo "$VERSION_CODENAME") stable" \
      > /etc/apt/sources.list.d/docker.list
    apt-get update -y
    apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
    systemctl enable docker
    systemctl start docker
  else
    info "Docker already installed"
  fi

  if ! docker compose version >/dev/null 2>&1; then
    error "Docker Compose v2 (docker compose) not found"
    exit 1
  fi

  success "Docker and Compose are ready"
}

prepare_env() {
  info "Preparing production environment variables"
  cd "$PROJECT_DIR"

  # Ensure host gateway mapping in compose works on Linux
  # backend service in docker-compose.yml already sets:
  #   extra_hosts: ["host.docker.internal:host-gateway"]

  # Create/update .env.prod for compose/env consumption
  # Prefer existing values from loaded environment; CLI args override; defaults fill the rest
  # Compute API base URL: prefer existing VITE_API_BASE_URL; else derive from DOMAIN; else fallback
  local computed_api_base
  if [[ -n "${VITE_API_BASE_URL:-}" ]]; then
    computed_api_base="${VITE_API_BASE_URL}"
  elif [[ -n "${DOMAIN}" ]]; then
    computed_api_base="https://${DOMAIN}"
  else
    computed_api_base="http://localhost:3001"
  fi

  cat > .env.prod <<EOF
# --- Generated by deploy-tencent.sh ---
# Server domain
SERVER_HOST=0.0.0.0
PORT=3001
GIN_MODE=release

# Database (host MySQL)
DB_HOST=${DB_HOST}
DB_PORT=${DB_PORT}
DB_USER=${DB_USER}
DB_PASSWORD=${DB_PASSWORD}
DB_NAME=${DB_NAME}
DB_SSLMODE=disable
DB_TIMEZONE=Asia/Shanghai

# Redis (internal container)
REDIS_HOST=redis
REDIS_PORT=6379

# JWT
JWT_SECRET=${JWT_SECRET}
JWT_EXPIRES_IN=24h

# Frontend build API base
# DOMAIN is optional; if set, used to derive VITE_API_BASE_URL
DOMAIN=${DOMAIN}
ENVIRONMENT=production
VITE_API_BASE_URL=${computed_api_base}
EOF

  success ".env.prod written"
}

check_mysql_connectivity() {
  info "Checking MySQL connectivity from host (optional)"
  if command -v mysql >/dev/null 2>&1; then
    if mysql -u"${DB_USER}" -p"${DB_PASSWORD}" -e \
      "CREATE DATABASE IF NOT EXISTS \`${DB_NAME}\` CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;"; then
      success "MySQL reachable and database ensured: ${DB_NAME}"
    else
      warn "Could not verify MySQL connectivity. Ensure credentials are correct and MySQL listens on localhost."
    fi
  else
    warn "mysql client not installed on host; skipping connectivity check"
  fi
}

ensure_ssl_files() {
  local ssl_dir="$PROJECT_DIR/docker/nginx/ssl"
  mkdir -p "$ssl_dir"
  if [[ ! -f "$ssl_dir/fullchain.pem" || ! -f "$ssl_dir/privkey.pem" ]]; then
    warn "SSL certs not found. Nginx will still start, but HTTPS will fail if config requires certs."
    warn "Place certs at: docker/nginx/ssl/fullchain.pem and docker/nginx/ssl/privkey.pem"
  else
    success "SSL certs found"
  fi
}

bring_up_stack() {
  info "Building and starting services with production profile"
  cd "$PROJECT_DIR"
  # Export env file variables for compose build context
  set -a; source .env.prod; set +a

  docker compose --env-file .env.prod -f docker-compose.prod.yml build backend
  docker compose --env-file .env.prod -f docker-compose.prod.yml up -d

  success "Services started"
}

post_checks() {
  info "Running health checks"
  docker compose ps
  sleep 3
  info "Recent backend logs (last 60 lines)"
  docker compose logs --tail 60 backend || true
  info "Recent nginx logs (last 60 lines)"
  docker compose logs --tail 60 nginx || true
}

configure_firewall() {
  if command -v ufw >/dev/null 2>&1; then
    info "Configuring UFW to allow 80/443"
    ufw allow 80/tcp || true
    ufw allow 443/tcp || true
  fi
}

main() {
  require_root
  load_existing_env
  parse_args "$@"
  check_os
  install_prereqs
  prepare_env
  check_mysql_connectivity
  ensure_ssl_files
  configure_firewall
  bring_up_stack

  success "Deployment completed"
  echo
  info "Next steps:"
  echo "- Point your domain (${DOMAIN}) DNS A record to this server's public IP"
  echo "- Ensure MySQL is running on host and accessible locally (bind-address=127.0.0.1)"
  echo "- If SSL certs are missing, add them to docker/nginx/ssl and re-run: docker compose --profile production up -d --build"
}

main "$@"
